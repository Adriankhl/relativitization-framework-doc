% arara: pdflatex
% arara: biber
% arara: pdflatex
% arara: clean: { extensions: [ acn,acr,alg,aux,bcf,blg,glg,glo,gls,idx,ilg,ind,ist,log,lof,lol,lot,out,ptc,toc,run.xml ]}

\documentclass{article}

\usepackage{arxiv}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{amsmath}
\usepackage{cleveref}       % smart cross-referencing
\usepackage{lipsum}         % Can be removed after putting your text content
\usepackage{graphicx}
%\usepackage[square,sort,comma,numbers]{natbib}
%\usepackage{natbib}
\usepackage{doi}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage[sorting=none]{biblatex}
\bibliography{references.bib}

\algblock{Input}{EndInput}
\algnotext{EndInput}
\algblock{Output}{EndOutput}
\algnotext{EndOutput}
\algblock{Data}{EndData}
\algnotext{EndData}
\newcommand{\Desc}[2]{\State \makebox[2em][l]{#1}#2}
\title{On social simulation in 4D relativistic spacetime}

% Here you can change the date presented in the paper title
%\date{September 9, 1985}
% Or remove it
%\date{}

\author{
	Lai Kwun Hang \\
	Centre for Science and Technology Studies (CWTS) \\
	Leiden University \\
	\texttt{k.h.lai@cwts.leidenuniv.nl} \\
	%% examples of more authors
	%\And
	%\href{https://orcid.org/0000-0000-0000-0000}{\includegraphics[scale=0.06]{orcid.pdf}\hspace{1mm}Elias D.~Striatum} \\
	%Department of Electrical Engineering\\
	%Mount-Sheikh University\\
	%Santa Narimana, Levand \\
	%\texttt{stariate@ee.mount-sheikh.edu} \\
	%% \AND
	%% Coauthor \\
	%% Affiliation \\
	%% Address \\
	%% \texttt{email} \\
	%% \And
	%% Coauthor \\
	%% Affiliation \\
	%% Address \\
	%% \texttt{email} \\
	%% \And
	%% Coauthor \\
	%% Affiliation \\
	%% Address \\
	%% \texttt{email} \\
}

% Uncomment to override  the `A preprint' in the header
%\renewcommand{\headeright}{Technical Report}
%\renewcommand{\undertitle}{Technical Report}
\renewcommand{\shorttitle}{\textit{arXiv} Template}

%%% Add PDF metadata to help others organize their library
%%% Once the PDF is generated, you can check the metadata with
%%% $ pdfinfo template.pdf
\hypersetup{
pdftitle={On social simulation in 4D relativistic spacetime},
%pdfsubject={q-bio.NC, q-bio.QM},
pdfauthor={Lai Kwun Hang},
%pdfkeywords={First keyword, Second keyword, More},
}

\begin{document}
\maketitle

\begin{abstract}
Agent-based models (ABM) and simulations are becoming more prominent in social science.
A major advantage of ABM is that it allows social scientists to explore hypothetical scenarios.
If we stretch our imagination, one of the interesting social science scenarios would be our interstellar future.
However, modeling an interstellar society requires relativistic physics,
which is not straightforward to implement in existing ABM frameworks.
In this paper, we present the mathematics and algorithmic details needed for simulating ABM in 4D relativistic spacetime.
These algorithms form the basis of our open-source computational framework, ``Relativitization''~\cite{relativitization}.
\end{abstract}


% keywords can be removed
\keywords{Special relativity \and Agent-based model \and Software framework}


\section{Introduction}
An agent-based model (ABM) is a simulation model bridging microscopic behaviours of agents and macroscopic observations.
Depending on the context of the model, an agent can be an individual, an organization, or as big as a country.
Assumption about the social behaviours of the agents are made, then the agents are placed and evolved
in a computational environment.
Modeling computational agents enforces social scientists to make explicit assumptions,
which helps formalizing the discussion on mechanisms and phenomena in the society.

In some research projects, if data collection is viable, 
ABM can be used to explain and predict the data.
In many other cases, it is not practical to expect model calibration with data,
where ABM can still be used for illustration and theoretical exposition in these cases~\cite{edmonds2015simulating}.
In this paper, we are interested in modeling interstellar society, and it certainly belongs to the latter category.

The scientific and technological advancement in the last century greatly increases our understanding of the universe.
Nowadays, we are able to build giant telescope and observe astronomical objects billions of light years away.
Apart from deeping our scientific understanding, the astronomical knowledge also stimulate our imagination
of interstellar civilizations.
A lot of great science fictions have been written, and scientists proposed ideas like 
Fermi paradox~\cite{gray2015fermi}, Dyson sphere~\cite{wright2020dyson} and Kardashev scale~\cite{gray2020extended}.
While many of the ideas are physically plausible, 
it would be interesting to discuss about these ideas in the context of social science.
Due to the highly hypothetical nature of the problem,
we suggested that ABM can be used to generate formal academic discussion on interstellar society.

To model agents in an interstellar space, supposed we only consider a scale with normal stellar objects
where we can ignore the effects of general relativity, such as universe expansion and black holes,
we still have to consider the effect of special relativity.
In the context of ABM, where we the simulation is computed under a single inertial frame,
we can simplify the theory of relativity into two core
phenomena: speed of light as the upper bound of the speed of information travel, and
time dilation relative to any stationary observer in the inertial frames.
This also implies that we have to take care of four dimensions: three space dimension, plus one time dimensions.

Typically, an ABM is constructed on top of an ABM framework to facilitate model development and communication.
There are a lot existing ABM framework, to name a few, NetLogo~\cite{netlogo}, mesa~\cite{python-mesa-2020},
and Agents.jl~\cite{Agents2021}, see~\cite{pal2020review} for a detailed review.
While it is possible to build a 4D relativistic model in some existing ABM frameworks, it is not easy to
enforce the relativistic effect, and it can be error-prone.
Therefore, we have developed a simulation framework we call ``Relativitization''~\cite{relativitization},
to help social scientists to build their ABM in relativistic spacetime.
In this paper, the mathematics and the algorithms under the framework will be presented.

\section{Definitions}

In Relativitization, an agent is called a ``player''.
Players live in a universe, and all the computation is done according to an inertial frame of the universe.
The spatial coordinates of a player are represented by floating-point numbers $x$, $y$ and $z$
where the time coordinate of the player is represented by a floating-point number $t$.
To simplify computation and visualization, the universe is partitioned into unit cubes.
A player with floating-point coordinates $(t, x, y, z)$ is located at the cube 
with integer coordinates $T = \lfloor t \rfloor$, $X = \lfloor x \rfloor$, $Y = \lfloor y \rfloor$, $Z = \lfloor z \rfloor$,
note that the computations of a simulation are done at unit time steps and we can actually assume $T = t$.
Denote the speed of light as $c$.
In vector notation, define $\textbf{s} = (t, \overrightarrow{u}) = (t, x, y, z)$, and 
$\textbf{S} = (T, \overrightarrow{U}) = (T, X, Y, Z)$.

\subsection{Interval and time delay}

The spacetime interval between coordinates $\textbf{s}_i$ and $\textbf{s}_j$ is
\begin{equation}
    \|\textbf{s}_i - \textbf{s}_j\| = c^2 (t_i - t_j)^2 - (x_i - x_j)^2 - (y_i - y_j)^2 - (z_i - z_j)^2.
\end{equation}

If $\|\textbf{s}_i - \textbf{s}_j\| < 0$, it is called a spacelike interval, and events happen at the two coordinates
are not causally connected because no information can travel faster than the speed of light $c$.

It is often needed to compute the interval in integer coordinates.
We define the spatial distance between $\overrightarrow{U_i}$
and $\overrightarrow{U_j}$ as the maximum distance between all points in the cubes at 
$\overrightarrow{U_i}$ and $\overrightarrow{U_j}$
\begin{equation} \label{eq:delay}
    |\overrightarrow{U_i} - \overrightarrow{U_j}| = (X_i - X_j + 1)^2 + (Y_i - Y_j + 1)^2 + (Z_i - Z_j + 1)^2.
\end{equation}

Suppose there is a signal sent from $\overrightarrow{U_i}$ to $\overrightarrow{U_j}$, 
to ensure that the information travels slower than the speed of light, 
the integer time delay $td(\overrightarrow{U_i}, \overrightarrow{U_j})$ is computed as
\begin{equation} 
    td(\overrightarrow{U_i}, \overrightarrow{U_j}) = \left \lceil \frac{|\overrightarrow{U_i} - \overrightarrow{U_j}|}{c} \right \rceil.
\end{equation}

\subsection{Group id}

From Eq.\ref{eq:delay}, even if $\overrightarrow{U_i} = \overrightarrow{U_j}$, the time delay is non-zero.
However, when two players are really closed to each other, the time delay between the players should be zero.

To allow zero time delay, we define a group id $g(\overrightarrow{u}, \overrightarrow{U})$ of a player as

\begin{align*}
    n_e &= \left \lceil \frac{1}{d_e} \right \rceil, \\
    n_x &= \left \lfloor \frac{x - X} {d_e} \right \rfloor, \\
    n_y &= \left \lfloor \frac{y - Y} {d_e} \right \rfloor, \\
    n_z &= \left \lfloor \frac{z - Z} {d_e} \right \rfloor,
\end{align*}

\begin{equation} \label{eq:group}
    g(\overrightarrow{u}, \overrightarrow{U}) = n_x n_e^2 + n_y n_e + n_z,
\end{equation}
where $d_e$ is the edge length of a smaller cube inside the unit cube.

If two players have same integer coordinates and same group id,
they are both located in a smaller cube defined by $d_e$, 
and we say the players belong the same group and the time delays between the players are zero.

\subsection{Player data}

A player is characterized by a set of data:
\begin{itemize}
  \item player id $i$,
  \item integer coordinates $(T_i, X_i, Y_i, Z_i)$,
  \item a historical record of integer coordinates $H_i = \{(T_i', X_i', Y_i', Z_i'), T_i' < T_i \}$,
  \item floating-point coordinates $(t_i, x_i, y_i, z_i)$,
  \item dilated time residue $r_i$, a floating point variable to store the effect of time dilation,
  \item dilation action $b_{ri}$ is a boolean variable to determine the impact of time dilation,
  \item group id $g_i$,
  \item floating-point velocities $\overrightarrow{v_i} = (v_{ix}, v_{iy}, v_{iz})$,
  \item other data $D_i$ relevant to the model.
\end{itemize}

\subsection{Command}

Interaction in ABM is often presented as one player asking
another player to do something.
Because the speed of information travel is bounded by $c$,
a player cannot simply ask other players to do something immediately.
Instead, interactions are mediated by commands.
Whenever player $i$ wants to interact with player $j$, 
player $i$ send a command to $j$. 

A command is characterized by:
\begin{itemize}
  \item $i_{\textrm{to}}$, the id of the player to receive this command,
  \item $i_{\textrm{from}}$ the id of the target player who sent this command,
  \item $\textbf{s}_{\textrm{from}}$ the coordinates when the player sent this command,
  \item $f_{\text{self}}$ a function to modify data of the sender when this is sent,
  \item $f_{\text{target}}$ a function to modify data of the target player when this is received.
\end{itemize}

Commands travel at the speed of light $c$.
The amount of time needed for a command to reach the target depends on the 
trajectory of the target player $i_{\textrm{to}}$ and the sender coordinates $\textbf{s}_{\textrm{from}}$,

\subsection{Universe data}

Universe is a simulation model which aggregates all necessary data and functionalities.
An universe has:
\begin{itemize}
  \item a current universe time $T_{\textrm{current}}$,
  \item a 4-dimension array of player data list $L_{TXYZ}$, player data that belongs to
        $(T, X, Y, Z)$ should be stored at the corresponding list,
  \item a map from player id to command $M_c$, storing lists of commands sending to players,
  \item other universe global data $D_G$ relevant to the model,
  \item an AI function $f_{\textrm{AI}}$, given an environment observed by a player, the function
        determine the commands sent from the player at every turn,
  \item a regular mechanism function $f_{\textrm{rm}}$, to modify the player data and generate commands 
        at every turn,
  \item a dilated mechanism function $f_{\textrm{dm}}$, to modify the player data and generate commands 
        at turns that are not affected by time dilation,
  \item a global mechanism function $f_{\textrm{gm}}$, to modify the global data.
\end{itemize}

The AI function $f_{\textrm{AI}}$ and the regular mechanism function $f_{\textrm{rm}}$ have similar
functionalities. 
In fact, it is possible to ignore either $f_{\textrm{AI}}$ or $f_{\textrm{rm}}$
in many simple models.
The major difference between the two is that AI function is more restricted, i.e., 
it can only modify its own player data through commands, 
where the regular mechanism function can do whatever it wants to modify the player data.
In a more complex model, it is clearer to separate the cognitive decision of a player ($f_{\textrm{AI}}$)
and the passive process from mechanisms ($f_{\textrm{rm}}$ and $f_{\textrm{dm}}$).

\subsection{3D view} \label{ssec:view}

At any moment, a player can only observe a 3D slice of the universe instead of viewing the full 4D array $L_{TXYZ}$, 
Denote $V_i$ as the 3D view of the universe from the viewpoint of player $i$, 
where the player's time is equal to the current universe time $T_i = T_{\textrm{current}}$.
$V_i$ is characterized by:
\begin{itemize}
  \item a map from player id to player data, these are the player data in the universe that player $i$ should see,
  \item the part of the universe global data $D_G$ that should be exposed to players.
\end{itemize}

Computation of $V_i$ can be decomposed into 2 stages. 
Firstly, if we ignore the fact that the time delay between players with the same group id and same integer coordinates is zero,
all players in a cube share the same 3D view of the universe. 
Algorithm~\ref{alg:viewAtCube} compute the shared 3D view at the coordinates $(T_i, X_i, Y_i, Z_i)$.
Then, $V_i$ can be computed from the shared 3D view by Algorithm~\ref{alg:viewAtPlayer}.
In fact, all players in the cube with the same group id has exactly the same 3D view.

\begin{algorithm}
\caption{Algorithm to compute a map of player id to player data viewed from the coordinates $(T_i, X_i, Y_i, Z_i)$}
\label{alg:viewAtCube}
\begin{algorithmic}[1]
  \Input
    \Desc{$T_i, X_i, Y_i, Z_i$ position of the viewing location}
    \Desc{$L_{TXYZ}$ 4D array of player data list}
  \EndInput
  \Output
    \Desc{Map from player id to player data}
  \EndOutput
  \Data
    \Desc{M}{map from player id to player data}
  \EndData
  \ForAll{$X_j, Y_j, Z_j$}
    \State $T_j \gets T_i - td(\overrightarrow{U_i}, (X_j, Y_j, Z_j))$ 
    \ForAll{data of player $k$ in $L_{T_j X_j Y_j Z_j}$}
      \If{$M$ has key $k$}
        \If{$T$ of $M[k]$ < $T_k$}
          \State Replace data of player $k$ in $M[k]$
        \EndIf
      \Else
        \State Store data of player $k$ to $M[k]$
      \EndIf
    \EndFor
  \EndFor
  \State \Return $M$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Algorithm to compute view $V_i$ of player $i$}
\label{alg:viewAtPlayer}
\begin{algorithmic}[1]
  \Input
    \Desc{$i$ the id of the target player}
    \Desc{$L_{TXYZ}$ 4D array of player data list}
  \EndInput
  \Output
    \Desc{$V_i$}{3D view of player $i$}
  \EndOutput
  \Data
    \Desc{$M$}{map from player id to player data}
  \EndData
  \State Compute $M$ by Algorithm~\ref{alg:viewAtCube}
  \ForAll{player data in $L_{T_i X_i Y_i Z_i}$}
    \If{same group id as player $i$}
      \If{$M$ has key $k$}
        \If{$T$ of $M[k]$ < $T_k$}
          \State Replace data of player $k$ in $M[k]$
        \EndIf
     \Else
       \State Store data of player $k$ to $M[k]$
     \EndIf
   \EndIf
  \EndFor
  \State Construct $V_i$ from $M$ and the relevant part of $D_G$
  \State \Return $V_i$
\end{algorithmic}
\end{algorithm}

\section{Simulation step} \label{sec:simulation}

Supposed we have defined an universe model, a complete step in a simulation looks like:
\begin{enumerate}
  \item update the global data (Sec.~\ref{ssec:global}),
  \item compute time dilation effects for all players (Sec.~\ref{ssec:dilation}),
  \item process mechanisms for each player (Sec.~\ref{ssec:mechanisms},
  \item process the command map (Sec.~\ref{ssec:command}),
  \item compute and process AI inputs (Sec.~\ref{ssec:ai}),
  \item move players, add afterimages, and update time (Sec.~\ref{ssec:move}).
\end{enumerate}

The simulation can be ran for a fixed amount of steps, or stop until a stopping condition is matched.

\subsection{Update global data} \label{ssec:global}

The universe global data $D_G$ can be separated into 4 parts:
\begin{itemize}
  \item immutable, not observable by players: such as data saved directory,
  \item immutable, observable by players: such as the dimension of the universe,
  \item mutable, not observable by players: such as statistics of the model,
  \item mutable, observable by players: such as variables in some of the mechanisms.
\end{itemize}

Immutable data does not need to be updated.
Mutable data that is not observable by players can be updated without any restriction.
The only part where we need to pay extra attention to is the mutable data that is observable by players.
If $f_{\textrm{gm}}$ depends on some player data to update the global data, 
and the effect is observable by players,
we need to ensure that no information is transferred faster than the speed of light via
the global data update.

For example, if $f_{\textrm{gm}}$ updates a data if ``all'' player data satisfy a condition,
we have to be careful about what do we mean by ``all'' here.
In the universe, the maximum time delay equals $td_{\textrm{max}} = td((0, 0, 0), (max(X), max(Y), max(Z)))$.
To fulfill the speed of light requirement, $f_{\textrm{gm}}$ has to check whether all player data in
$L_{TXYZ}$, where $T_{\textrm{current}} - td_{\textrm{max}} \leq T \leq T_{\textrm{current}}$,
$0 \leq X \leq max(X)$, $0 \leq Y \leq max(Y)$, and $0 \leq Z \leq max(Z)$,
satisfy the condition.

\subsection{Compute time dilation} \label{ssec:dilation}

Relative to a stationary observer $i$ in an inertial frame,
special relativity predicts that a moving observer $j$ experiences a time dilation effect:

\begin{equation} \label{eq:gamma}
  \gamma_j = \frac{1}{\sqrt{1 - \frac{v_j^2}{c^2}}},
\end{equation}

\begin{equation}
  \Delta t_j = \frac{1}{\gamma_j} \Delta t_i,
\end{equation}
where $\gamma_j$ is called the Lorentz factor.

Ideally, computation should be done in every local frame following all players, 
and the computation results can be synchronized by Lorentz transformation.
However, this will make the framework and the model substantially more complex.
Therefore, all computations in Relativitization are done in a single inertial frame.
To account for the time-dilation effect, the dilated time residue $r_i$, 
and the dilation action variable $b_{ri}$ are updated by Algorithm~\ref{alg:dilation}
every turn for every player. 
$b_{ri}$ will then affect the mechanism processing in Sec.~\ref{ssec:mechanisms}.

\begin{algorithm}
\caption{Algorithm to update time dilation variables}
\label{alg:dilation}
\begin{algorithmic}[1]
  \Input
    \Desc{Player data of player $i$}
  \EndInput
  \State Compute $\gamma_i$ by Eq.~\ref{eq:gamma}
  \State $r_i \gets r_i + \frac{1}{\gamma_i}$
  \If{$r_i \geq 1$}
    \State $r_i \gets r_i - 1$
    \State $b_{ri} \gets \textrm{true}$
  \Else  
    \State $b_{ri} \gets \textrm{false}$
  \EndIf
\end{algorithmic}
\end{algorithm}

\subsection{Process mechanisms} \label{ssec:mechanisms}

Mechanism is one of the major components of the universe model.
Given the 3D view $V_i$ of a player $i$, mechanisms describe
how the data of player $i$ should be updated, and which commands
should be generated from the process.

Mechanisms are classified into regular mechanism and dilated mechanism,
where dilated mechanism is affected by time dilation and regular mechanism is not.
For example, if a player should synchronize an internal state based on the state
of other player, then this should be a regular mechanism.
If a player needs to produce an output where the amount is proportional to time,
then this should be a dilated mechanism.

Since commands generated by mechanism should be executed immediately if the
time delay between the target and the sender is zero, it is more convenient
to consider all player data in a cube together in 
the mechanism processing algorithm, 
as demonstrated in algorithm.~\ref{alg:mechanisms}.
The output commands from Algorithm~\ref{alg:mechanisms} are then grouped by id of the target
player, and added to $M_c$ after randomizing the order of senders

\begin{algorithm}
\caption{Algorithm to update players in a cube by mechanisms}
\label{alg:mechanisms}
\begin{algorithmic}[1]
  \Input
    \Desc{Coordinates $(X', Y', Z')$}
  \EndInput
  \Output
    \Desc{A list of commands}
  \EndOutput
  \State Compute the shared 3D view by Algorithm~\ref{alg:viewAtCube}
  \ForAll{Group in $(X', Y', Z')$}
    \State Compute the 3D view for this group by Algorithm~\ref{alg:viewAtPlayer}
    \ForAll{player $i$ in group}
      \If{$b_{ri}$ is true}
        \State Update player data by $f_{\textrm{rm}}$ and $f_{\textrm{dm}}$,
      \Else
        \State Update player data by $f_{\textrm{rm}}$
      \EndIf
    \EndFor
    \ForAll{generated command}
      \If{target player is in this group}
        \State Update target player by $f_{\text{target}}$ 
      \EndIf
    \EndFor
  \EndFor
  \State \Return the rest of the generated commands
\end{algorithmic}
\end{algorithm}

\subsection{Process command map} \label{ssec:command}

The command map $M_c$ is a map from player id to a list of commands that is sending to that player.
At each turn, the distance between the target player and the sent positions of all commands in the list are calculated,
the command is executed on the player if the spacetime interval is larger than zero.
Algorithm~\ref{alg:command} illustrates the process.

\begin{algorithm}
\caption{Algorithm to process command map}
\label{alg:command}
\begin{algorithmic}[1]
  \Input
    \Desc{$M_c$ the command map}
  \EndInput
  \ForAll{key $i$ in $M_c$}
    \State Get list of command $M_c[i]$
    \ForAll{command $C$ in the list}
      \If{$\|\textbf{s}_{\textrm{from}} - \textbf{s}_i\| \geq 0$}
        \State Execute the command
      \EndIf
    \EndFor
  \EndFor
  \State Remove all executed commands
\end{algorithmic}
\end{algorithm}

\subsection{AI input} \label{ssec:ai}

The AI function $f_{\textrm{AI}}$ determines the commands to be sent given the 3D view of a player.
Unlike mechanisms, a command needs to be self-executed on the sender first,
then the command will be sent if the self-execution succeeded.
Similar to Sec.~\ref{ssec:mechanisms}, commands should be executed immediately if the
time delay between the target and the sender is zero, it is more convenient to
consider all player data in a cube in the algorithm, 
as demonstrated in Algorithm~\ref{alg:ai}.
The output commands from Algorithm~\ref{alg:ai} are then grouped by id of the target
player, and added to $M_c$ after randomizing the order of senders.

\begin{algorithm}
\caption{Algorithm to compute and process AI input}
\label{alg:ai}
\begin{algorithmic}[1]
  \Input
    \Desc{Coordinates $(X', Y', Z')$}
  \EndInput
  \Output
    \Desc{A list of commands}
  \EndOutput
  \State Compute the shared 3D view by Algorithm~\ref{alg:viewAtCube}
  \ForAll{group in $(X', Y', Z')$}
    \State Compute the 3D view for this group by Algorithm~\ref{alg:viewAtPlayer}
    \ForAll{player $i$ in group}
      \State Compute commands by $f_{\textrm{AI}}$
      \ForAll{command from player $i$}
        \State Self-execute the command by $f_{\text{self}}$
        \State Keep the command if succeeded
        \If{the target of the command is self}
          \State Execute the command to self by $f_{\text{target}}$
        \EndIf
      \EndFor
    \EndFor
    \ForAll{Command}
      \If{Target player is in this group}
        \State Update target player by $f_{\text{target}}$ 
      \EndIf
    \EndFor
  \EndFor
  \State \Return the rest of the generated commands
\end{algorithmic}
\end{algorithm}

\subsection{Move players, add afterimages, and update time} \label{ssec:move}

Moving players and storing their data require additional considerations in this simulation framework,
and here is the reason:
\begin{enumerate}
  \item assume player $i$ and player $j$ are located in the same cube,
  \item player $j$ moves to the other cube,
  \item the new information takes time to travel to player $i$, so player $i$ cannot see the new position of player $j$,
  \item player $i$ cannot see the old information of player $j$ either, because player $j$ is no longer there,
  \item player $j$ disappears from the sight of player $i$.
\end{enumerate}

This ``disappearance'' is caused by the problem of the integer-based coordinates used in the computation of player's 3D view.

Consider a more generic situation, supposed player $i$ is located at $\overrightarrow{U_i}$, 
and player $j$ moves from $\overrightarrow{U_j}$ to $\overrightarrow{U_k}$.
Ignoring the possibility of zero time delay, the maximum time player $i$ has to wait to see player $j$
is bounded by the Eq.~\ref{eq:deltaT},

\begin{align*}
  \Delta T &= td(\overrightarrow{U_i}, \overrightarrow{U_j}) - td(\overrightarrow{U_i}, \overrightarrow{U_k}), \\
  &= \left \lceil \frac{|\overrightarrow{U_i} - \overrightarrow{U_j}|}{c} \right \rceil - \left \lceil \frac{|\overrightarrow{U_i} - \overrightarrow{U_k}|}{c} \right \rceil,  \\
  &\leq \left \lceil \frac{|\overrightarrow{U_i} - \overrightarrow{U_j}|}{c} - \frac{|\overrightarrow{U_i} - \overrightarrow{U_k}|}{c} \right \rceil, \\
  &\leq \left \lceil \frac{|\overrightarrow{U_j} - \overrightarrow{U_k}|}{c} \right \rceil, \\
\end{align*}

\begin{equation} \label{eq:deltaT}
  \Delta T \leq td(\overrightarrow{U_j}, \overrightarrow{U_k}).
\end{equation}

Therefore, if we include back the possibility where the time delay between player $i$ and player $j$ can be zero,
the maximum duration of the disappearance produced by the movement is bounded by $\Delta T_{max} = td((0, 0, 0), (1, 1, 1))$.
To prevent the unrealistic disappearance from happening, the old player data has to stay at the original
position for at least $\Delta T_{max}$ turn, we call this the ``afterimage'' of the player.
Note that afterimages only participate in the 3D view of players, they should not be updated by commands or mechanisms.

Algorithm~\ref{alg:move} does multiple things: update the universe time, 
move players by their velocities, synchronize time of players,
store old coordinates to the history of player, clean the history if the stored coordinates is too old,
and add the afterimages to the latest data in the 4D data array.
Since the universe time has been updated, this simulation step has finished. 
The universe should go to the next step and loop over all algorithms in Sec.~\ref{sec:simulation} again.

\begin{algorithm}
\caption{Algorithm to move player, add afterimage, and update time}
\label{alg:move}
\begin{algorithmic}[1]
  \State $T_{\textrm{current}} \gets T_{\textrm{current}} + 1$
  \ForAll{player $i$}
    \State $t_i \gets T_{\textrm{current}}$
    \State $x_i \gets x_i + v_{ix}$
    \State $y_i \gets y_i + v_{iy}$
    \State $z_i \gets z_i + v_{iz}$
    \State $T_i \gets T_{\textrm{current}}$
    \State $X_i \gets \lfloor x_i \rfloor$
    \State $Y_i \gets \lfloor y_i \rfloor$
    \State $Z_i \gets \lfloor z_i \rfloor$
    \State $g_i \gets g(\overrightarrow{u_i}, \overrightarrow{U_i})$ by Eq.~\ref{eq:group}
    \If{coordinates or group is new}
      \State Save old coordinates to history $H_i$
    \EndIf
    \ForAll{$(T_i', X_i', Y_i', Z_i')$ in $H_i$}
      \State Remove if $T_{\textrm{current}} - T' > \Delta T_{max}$
    \EndFor
    \ForAll{$(T_i', X_i', Y_i', Z_i')$ in $H_i$}
      \State Add the old data to $L_{T_i X_i' Y_i' Z_i'}$
    \EndFor
  \EndFor
\end{algorithmic}
\end{algorithm}

\section{Discussion}

\subsection{New player and dead player}

Because creating new player and defining living status of players are not crucial to all ABM,
they are not introduced in Sec.~\ref{sec:simulation}.
In fact, Relativitization supports both creating new player and turning alive player to dead player.

To avoid violation of the speed of light limit, new player cannot be created freely anywhere.
Instead, a command has to be sent by a player, and the command executes on self or another player
to indicate in the player data that a new player should be created.
This information is visited by an algorithm every turn and a new player will be created at the location
of the player with this information.

To turn an alive player dead, there needs to be a command to execute on that to change the living status.
The dead player will not be processed by any algorithms in Sec.~\ref{sec:simulation}, but it will still
remain to be in the history stored in the 4D data array. Until no other player can see the player in their 3D view,
the dead player will disappear from the 4D data array.

\subsection{Time complexity, optimized 3D view}

The time complexity of a model depends on the actual design of mechanisms and AI computation.
If we assume that the extra computation costs are $O(1)$, then most of algorithms presented initial
this paper are $O(n)$, where $n$ is the number of players. The only exception is Algorithm~\ref{alg:viewAtCube},
it has the time complexity $O(n m)$, where $m$ is the spatial volume of the universe.

In practice, if we want to avoid $O(n)$ mechanisms and AI computation,
the model often need to get a set of neighbouring cubes around a player to determine
how the player should be updated. 
The map data structure of the 3D view introduced in Sec.~\ref{ssec:view}
does not have a fast method to get the neighbouring cubes.
Therefore, in the actual implementation of the 3D view of players in Relativitization,
the original map is supplemented with a 3D player id array to allow fast spatial lookup,
at the price of having a slower computation speed of 3D view.

\subsection{Parallelization}

The data flow in simulation framework is pretty straightforward,
most of the computations only depend on the historical data in the 4D array.
Therefore, as long as immutability of data is properly handled,
many of the algorithms can be easily parallelized.

In Relativitization, the mechanisms algorithm in Sec.~\ref{ssec:mechanisms}
and the AI input algorithm in Sec.~\ref{ssec:ai} are computed in parallel for each cube,
and the command map process algorithm in Sec.~\ref{ssec:command} is computed in parallel for each player.

\subsection{Rest mass and photon rocket}

There is an important aspect of physics we have yet to talk about in this paper - how should the velocity of player be changed?
Of course, an ABM does not necessary be physically realistic, and the velocity can change to whatever value
the modeler wants.
Nevertheless, the major goal of this simulation framework is to assure that the model obeys relativistic physics,
it makes sense to also be physically correct regarding the velocity.

A natural choice of a physically reasonable propulsion system is photon rocket~\cite{pierce1959relativity}.
In spite of the debates on various factors affecting the speed limit of a photon rocket~\cite{haug2017ultimate, tommasini2019comment}.
ideal photon rocket is a good starting point to introduce realism in how a player should move.

In order to formulate how a player is propelled by a photon rocket, 
we have to define a ``rest mass'' property in the extra player data $D_i$.
Denote the initial rest mass of the player as $m_i$ and the initial velocity as $\overrightarrow{v_i}$.
After the photon rocket propulsion,
denote the final rest mass of the player as $m_f$ and the final velocity as $\overrightarrow{v_f}$. 
Sometimes it is convenient to express $\overrightarrow{v_f}$ as $v_f \hat{v}_f$ to separate the magnitude and the unit vector.

In special relativity, 4-momentum is used to represent the kinematic state of an object.
There are 3 momenta involved in a photon rocket propulsion process:
\begin{itemize}
  \item photon 4-momentum: $P_{ph}$,
  \item player initial 4-momentum $P_i = (\gamma_i m_i c, \gamma_i m_i \overrightarrow{v_i}) $, 
        where $\gamma_i$ is the initial Lorentz factor,
  \item player final 4-momentum $P_f = (\gamma_f m_f c, \gamma_f m_f \overrightarrow{v_f})$, 
        where $\gamma_f$ is the final Lorentz factor.
\end{itemize}

One of the useful scenarios is that the player turn some rest mass into photon, i.e., $m_i > m_f$,
and given that the player will face towards a specific direction after the propulsion,
we want to know the final velocity $v_f$.
From conservation of 4-momentum:
\begin{align*}
    & P_{ph} = P_i - P_f, \\
    & P_{ph}^2 = P_i^2 + P_f^2 - 2 P_i \cdot P_f, \\
    & 0 = (m_i c)^2 + (m_f c)^2 - 2 \gamma_i \gamma_f m_i m_f ( c^2 - v_f \overrightarrow{v_i} \cdot \hat{v}_f), \\
    & (m_i c)^2 + (m_f c)^2 = \frac{2 \gamma_i m_i m_f}{\sqrt{1 - v_f^2 / c^2}} ( c^2 - v_f \overrightarrow{v_i} \cdot \hat{v}_f), \\
    & \left(\frac{(m_i c)^2 + (m_f c)^2}{2 \gamma_i m_i m_f}\right)^2 = \frac{(c^2 - v_f \overrightarrow{v_i} \cdot \hat{v}_f)^2}{1 - v_f^2 / c^2}, \\
    & \left(\frac{(m_i c)^2 + (m_f c)^2}{2 \gamma_i m_i m_f}\right)^2 (1 - v_f^2 / c^2) = c^4 - 2 c^2 v_f \overrightarrow{v_i} \cdot \hat{v}_f + v_f^2 (\overrightarrow{v_i} \cdot \hat{v}_f)^2. \\
\end{align*}

Eq.~\ref{eq:speed} is a quadratic equation, solving the equation gives us the solution of $v_f$:
\begin{align} \label{eq:speed}
\begin{split}
    &((\overrightarrow{v_i} \cdot \hat{v}_f)^2 + \left(\frac{(m_i)^2 + (m_f)^2}{2 \gamma_i m_i m_f}\right)^2 c^2) v_f^2 + \\
    &(- 2 c^2 \overrightarrow{v_i} \cdot \hat{v}_f) v_f + c^4 \left(1 - \left(\frac{(m_i)^2 + (m_f)^2}{2 \gamma_i m_i m_f}\right)^2 \right) = 0.
\end{split}
\end{align}

Another useful scenario is that given the final velocity $\overrightarrow{v_f}$,
we want to know the rest mass needed to be converted into photon.
\begin{align*}
    P_{ph} &= P_i - P_f \\
    P_{ph}^2 &= P_i^2 + P_f^2 - 2 P_i \cdot P_f \\
    0 &= (m_i c)^2 + (m_f c)^2 - 2 \gamma_i \gamma_f m_i m_f ( c^2 - \overrightarrow{v_i} \cdot \overrightarrow{v_f}) \\
\end{align*}

Eq.~\ref{eq:mass} is also a quadratic equation, solving this equation gives us the solution of $m_f$:
\begin{equation} \label{eq:mass}
    c^2 m_f^2 + (- 2 \gamma_i \gamma_f m_i ( c^2 - \overrightarrow{v_i} \cdot \overrightarrow{v_f})) m_f + (m_i c)^2 = 0.
\end{equation}

There are in-built utility functions in Relativitization to compute these solutions.
Nevertheless, modelers are free to implementation other more realistic propulsion equations in their model.

%TODO
%\subsection{Alternative implementation}

\section{Summary}

In this paper, we have presented a set of algorithms to implement ABM simulation in a 4D, relativistic spacetime.
Based on these algorithms, we have developed a simulation framework we call ``Relativitization''~\cite{relativitization}.
Our framework will lower the barrier of entry and encourage social scientists
to apply their expertise to explore the interstellar future of human civilization.
We hope our framework can be used to initiate meaningful and academically interesting discussions
about our future.

%\bibliographystyle{unsrt}
%\bibliography{references}  %%% Uncomment this line and comment out the ``thebibliography'' section below to use the external .bib file (using bibtex) .
\printbibliography


%%% Uncomment this section and comment out the \bibliography{references} line above to use inline references.
% \begin{thebibliography}{1}

% 	\bibitem{kour2014real}
% 	George Kour and Raid Saabne.
% 	\newblock Real-time segmentation of on-line handwritten arabic script.
% 	\newblock In {\em Frontiers in Handwriting Recognition (ICFHR), 2014 14th
% 			International Conference on}, pages 417--422. IEEE, 2014.

% 	\bibitem{kour2014fast}
% 	George Kour and Raid Saabne.
% 	\newblock Fast classification of handwritten on-line arabic characters.
% 	\newblock In {\em Soft Computing and Pattern Recognition (SoCPaR), 2014 6th
% 			International Conference of}, pages 312--318. IEEE, 2014.

% 	\bibitem{hadash2018estimate}
% 	Guy Hadash, Einat Kermany, Boaz Carmeli, Ofer Lavi, George Kour, and Alon
% 	Jacovi.
% 	\newblock Estimate and replace: A novel approach to integrating deep neural
% 	networks with existing applications.
% 	\newblock {\em arXiv preprint arXiv:1804.09028}, 2018.

% \end{thebibliography}


\end{document}
